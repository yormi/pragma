module Parser3.CombinatorSpec where

import Test.Hspec hiding (context)

import qualified Parser3.Error as E
import Parser3.Combinator
import Parser3.Position (Position(..))
import Parser3.Quote (Quote(..))
import Parser3.Parser


spec :: Spec
spec =
    let
        aFilePath = "some/File/Path.pa"

        testSuccess parser sourceCode expected =
            test parser sourceCode (Right expected)

        testFailure parser sourceCode expected =
            expected
                |> Left
                |> test parser sourceCode

        test parser sourceCode expected =
            parser
                |> run aFilePath sourceCode
                |> (`shouldBe` expected)
    in
    describe "Parser Combinators" <| do
        describe "anyChar" <| do
            it "Parses once" <|
                let
                    sourceCode =
                        "abc"

                    expected =
                        Parsed (Quote aFilePath 1 1 1 1) 'a'
                in
                testSuccess anyChar sourceCode expected


            it "Progress to next char after first one has been parsed" <|
                let
                    sourceCode =
                        "abc"

                    parser = do
                        a <- anyChar
                        b <- anyChar
                        return (a, b)

                    expected =
                        ( Parsed (Quote aFilePath 1 1 1 1) 'a'
                        , Parsed (Quote aFilePath 1 2 1 2) 'b'
                        )
                in do
                testSuccess parser sourceCode expected


            it "Fails given no remaining chars" <|
                let
                    sourceCode =
                        ""

                    parser =
                        anyChar

                    expected =
                        E.EndOfFileReached
                in do
                testFailure parser sourceCode expected


        describe "string" <| do
            it "Parses first word given splitted by space" <|
                let
                    sourceCode =
                        "two words"

                    expected =
                        Parsed
                            (Quote aFilePath 1 1 1 3)
                            "two"
                in
                string
                    |> run aFilePath sourceCode
                    |> (`shouldBe` Right expected)

            it "Parses first word given splitted by closing parenthesized" <|
                let
                    sourceCode =
                        "two)words"

                    expected =
                        Parsed
                            (Quote aFilePath 1 1 1 3)
                            "two"
                in
                string
                    |> run aFilePath sourceCode
                    |> (`shouldBe` Right expected)

            it "Parses first word given splitted by closing square bracket" <|
                let
                    sourceCode =
                        "two]words"

                    expected =
                        Parsed
                            (Quote aFilePath 1 1 1 3)
                            "two"
                in
                string
                    |> run aFilePath sourceCode
                    |> (`shouldBe` Right expected)


            it "Parses two words" <|
                let
                    sourceCode =
                        "two words"

                    parser = do
                        a <- string
                        _ <- space
                        b <- string
                        return (a, b)

                    expected =
                        ( Parsed
                            (Quote aFilePath 1 1 1 3)
                            "two"
                        , Parsed
                            (Quote aFilePath 1 5 1 9)
                            "words"
                        )
                in
                testSuccess parser sourceCode expected


            it "consumes the spaces before a word then parses the word" <|
                let
                    sourceCode =
                        "    two words"

                    parser =
                        string

                    expected =
                        Parsed
                            (Quote aFilePath 1 5 1 7)
                            "two"
                in
                testSuccess parser sourceCode expected


        describe "identifier" <| do
            it "Parses once given all legal id characters" <|
                let
                    sourceCode =
                        "two words"

                    expected =
                        Parsed
                            (Quote aFilePath 1 1 1 3)
                            "two"
                in
                testSuccess identifier sourceCode expected


            it "consumes the spaces before a word then parses the identifier" <|
                let
                    sourceCode =
                        "  someId"

                    parser =
                        identifier

                    expected =
                        Parsed
                            (Quote aFilePath 1 3 1 8)
                            "someId"
                in
                testSuccess parser sourceCode expected


            it "Fails given a string with characters that are not valid identifier characters" <|
                let
                    sourceCode =
                        "two$ words"

                    parser = do
                        a <- identifier
                        b <- identifier
                        return (a, b)

                    expected =
                        [ (Position aFilePath 1 4, '$') ]
                            |> E.InvalidCharactersInIdentifier
                in
                testFailure parser sourceCode expected


            it "Fails given the provided word is in the reserved words" <|
                let
                    reservedWord =
                        "else"

                    sourceCode =
                        reservedWord

                    parser =
                        identifier

                    expected =
                        E.IdentifierCantBeAReservedWord
                            (Quote aFilePath 1 1 1 4)
                            reservedWord
                in do
                testFailure parser sourceCode expected


        describe "reserved" <| do
            it "Returns the quote given the string is the one provided" <|
                let
                    sourceCode =
                        "if True then"

                    parser =
                        reserved "if"

                    expected =
                        Quote aFilePath 1 1 1 2
                            |> \q -> Parsed q ()
                in do
                testSuccess parser sourceCode expected


            it "Fails given the provided word is not in the reserved words" <|
                let
                    typoed =
                        "esle"

                    sourceCode =
                        typoed

                    parser =
                        reserved typoed

                    expected =
                        E.ThisIsABug
                            (Position aFilePath 1 1)
                            "esle is not a reserved word"
                in do
                testFailure parser sourceCode expected


            it "Fails given the read string was not the one desired" <|
                let
                    sourceCode =
                        "else"

                    reservedWord =
                        "if"

                    parser =
                        reserved reservedWord

                    expected =
                        E.ReservedWordExpected
                            (Quote aFilePath 1 1 1 4)
                            reservedWord
                in do
                testFailure parser sourceCode expected


        describe "operator" <| do
            it "Returns the quote given the string is the one provided" <|
                let
                    sourceCode =
                        "=="

                    parser =
                        operator "=="

                    expected =
                        Quote aFilePath 1 1 1 2
                            |> \q -> Parsed q ()
                in do
                testSuccess parser sourceCode expected


            it "Returns the quote given the first chars represent the operator even if there is no space after" <|
                let
                    sourceCode =
                        "==banana"

                    parser =
                        operator "=="

                    expected =
                        Quote aFilePath 1 1 1 2
                            |> \q -> Parsed q ()
                in do
                testSuccess parser sourceCode expected


            it "Returns the quote even if there is spaces in front of the operator" <|
                let
                    sourceCode =
                        " =="

                    parser =
                        operator "=="

                    expected =
                        Quote aFilePath 1 2 1 3
                            |> \q -> Parsed q ()
                in do
                testSuccess parser sourceCode expected


            it "Fails given the provided word is not in the operator list" <|
                let
                    typoed =
                        "!="

                    sourceCode =
                        typoed

                    parser =
                        operator typoed

                    expected =
                        E.ThisIsABug
                            (Position aFilePath 1 1)
                            "!= is not an operator"
                in do
                testFailure parser sourceCode expected


            it "Fails given the read string was not the one desired" <|
                let
                    sourceCode =
                        "="

                    reservedWord =
                        ":"

                    parser =
                        operator reservedWord

                    expected =
                        E.OperatorExpected
                            (Position aFilePath 1 1)
                            reservedWord
                in do
                testFailure parser sourceCode expected


            it "Fails as a bug given the provided string is empty" <|
                let
                    sourceCode =
                        "="

                    parser =
                        operator ""

                    expected =
                        E.ThisIsABug
                            (Position aFilePath 1 1)
                            "The required operator should not be empty"
                in do
                testFailure parser sourceCode expected


        describe "oneOf" <|
            let
                aPosition =
                    Position aFilePath 1 1

                anError =
                    E.ThisIsABug aPosition "anError"
            in do
            it "Returns the successful parser value given the first parser succeed" <|
                let
                    sourceCode =
                        "if False then"

                    parser =
                        oneOf
                            anError
                            [ reserved "if"
                            , operator "{"
                            ]

                    expected =
                        Quote aFilePath 1 1 1 2
                            |> \q -> Parsed q ()
                in do
                testSuccess parser sourceCode expected


            it "Returns the successful parser value given the second parser succeeded" <|
                let
                    sourceCode =
                        "{ hello = \"world\" }"

                    parser =
                        oneOf
                            anError
                            [ reserved "if"
                            , operator "{"
                            ]

                    expected =
                        Quote aFilePath 1 1 1 1
                            |> \q -> Parsed q ()
                in do
                testSuccess parser sourceCode expected


            it "Fails with the provided error given no parser succeeds" <|
                let
                    sourceCode =
                        "+"

                    parser =
                        oneOf
                            anError
                            [ reserved "if"
                            , operator "{"
                            ]

                    expected =
                        anError
                in do
                testFailure parser sourceCode expected


        describe "many" <| do
            it "Returns a list of the parsed value" <|
                let
                    sourceCode =
                        "a b c d"

                    parser =
                        many <| do
                            id <- identifier
                            _ <- maybe space
                            return id

                    expected =
                        [ Parsed (Quote aFilePath 1 1 1 1) "a"
                        , Parsed (Quote aFilePath 1 3 1 3) "b"
                        , Parsed (Quote aFilePath 1 5 1 5) "c"
                        , Parsed (Quote aFilePath 1 7 1 7) "d"
                        ]
                in do
                testSuccess parser sourceCode expected


            it "Returns an empty list given unable to parse even once" <|
                let
                    sourceCode =
                        ""

                    parser =
                        many identifier

                    expected =
                        []
                in do
                testSuccess parser sourceCode expected


        describe "atLeastOne" <| do
            it "Returns a list of the parsed value" <|
                let
                    sourceCode =
                        "a b c d"

                    parser =
                        many <| do
                            id <- identifier
                            _ <- maybe space
                            return id

                    expected =
                        [ Parsed (Quote aFilePath 1 1 1 1) "a"
                        , Parsed (Quote aFilePath 1 3 1 3) "b"
                        , Parsed (Quote aFilePath 1 5 1 5) "c"
                        , Parsed (Quote aFilePath 1 7 1 7) "d"
                        ]
                in do
                testSuccess parser sourceCode expected


        describe "maybe" <| do
            it "Returns Nothing given the given parser is not successful" <|
                let
                    sourceCode =
                        ""

                    parser =
                        maybe string

                    expected =
                        Nothing
                in do
                testSuccess parser sourceCode expected


            it "Returns Just with the parsed value given a successful parser" <|
                let
                    sourceCode =
                        "yo"

                    parser =
                        maybe string

                    expected =
                        Parsed (Quote aFilePath 1 1 1 2) "yo"
                            |> Just
                in do
                testSuccess parser sourceCode expected


        describe "parenthesized" <| do
            it "Parses successfully given no spaces" <|
                let
                    sourceCode =
                        "(yo)"

                    parser =
                        parenthesized string

                    expected =
                        Parsed (Quote aFilePath 1 2 1 3) "yo"
                in do
                testSuccess parser sourceCode expected


            it "Parses successfully given spaces before the opening parenthesis" <|
                let
                    sourceCode =
                        "  (yo)"

                    parser =
                        parenthesized string

                    expected =
                        Parsed (Quote aFilePath 1 4 1 5) "yo"
                in do
                testSuccess parser sourceCode expected


            it "Parses successfully given spaces after the opening parenthesis" <|
                let
                    sourceCode =
                        "(  yo)"

                    parser =
                        parenthesized string

                    expected =
                        Parsed (Quote aFilePath 1 4 1 5) "yo"
                in do
                testSuccess parser sourceCode expected


            it "Parses successfully given spaces before the closing parenthesis" <|
                let
                    sourceCode =
                        "(yo  )"

                    parser =
                        parenthesized string

                    expected =
                        Parsed (Quote aFilePath 1 2 1 3) "yo"
                in do
                testSuccess parser sourceCode expected


            it "Fails given no opening parenthesis" <|
                let
                    sourceCode =
                        "yo)"

                    parser =
                        parenthesized string

                    expected =
                        E.NotTheDesiredChar (Position aFilePath 1 1) '('
                in do
                testFailure parser sourceCode expected


            it "Fails given no closing parenthesis" <|
                let
                    sourceCode =
                        "(yo bob"

                    parser =
                        parenthesized string

                    expected =
                        E.NotTheDesiredChar (Position aFilePath 1 5) ')'
                in do
                testFailure parser sourceCode expected
