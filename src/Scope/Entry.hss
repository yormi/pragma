module Scope.Entry
    ( scope
    ) where

import Control.Monad.Trans.Except (ExceptT)
import Control.Monad.Trans.Reader (ReaderT)
import Control.Monad.Trans.Writer (Writer)

import AST.Expression (Expression)
import AST.Identifier (ReferenceId)
import qualified AST.Module as M
import Parser.Model.Quote (Quote)


-- Goal:
--   * Replaces Params and Let..In
--   * Orders constraint solving depending on let definitions dependencies
--   * Does not touch ModuleContext
--   * Ends with an ordered [( ScopeContext, Expression )]


type ScopeContext =
    Map Reference T.Type


scopeExpression :: M.TopLevel -> [( ScopeContext, Expression )]
scopeExpression topLevel =
    []


type Scope a =
    ExceptT Error
        (ReaderT AvailableReferences
            (Writer [ScopedExpression])
        )
        a


data Error =
    NameClash
        { name :: ReferenceId
        , previously :: Quote
        , now :: Quote
        }
        deriving (Eq, Show)


type ScopedExpression =
    ( AvailableReferences, Expression)


type AvailableReferences =
    Map ReferenceId (Quote, Placeholder)


type Placeholder =
    Int


scope :: Scope ()
scope =
    return ()
