module Type.Constraint.Gatherer.Context (Context(..), gatherer) where

import qualified Control.Monad as Monad
import Data.List.NonEmpty (NonEmpty)

import AST.Identifier (DataId, TypeId, TypeVariableId)
import qualified AST.Module as M
import AST.TypeAnnotation (TypeAnnotation)
import qualified AST.TypeAnnotation as TypeAnnotation
import qualified Type.Model as T
import qualified Type.Constraint.Model as Constraint
import Type.Constraint.Gatherer.Context.Model (Context)
import qualified Type.Constraint.Gatherer.Context.Model as Context
import Type.Constraint.Gatherer.Model (Gatherer)
import qualified Type.Constraint.Gatherer.Model as Gatherer
import qualified Type.Constraint.Gatherer.TypeAnnotation as TypeAnnotation
import qualified Utils.List as List
import qualified Utils.Maybe as Maybe
import Utils.OrderedSet (OrderedSet)


gatherer :: M.Module -> Gatherer Context
gatherer (M.Module topLevels) = do
    contextWithTypes <- typeGatherer topLevels

    Gatherer.withContext contextWithTypes <|
        dataGatherer topLevels contextWithTypes


typeGatherer :: [M.TopLevel] -> Gatherer Context
typeGatherer topLevels =
    let
        gatherSumType typeName context =
            Context.defineType typeName context
                |> map return
                |> Maybe.withDefault
                    (Gatherer.fail Gatherer.TypeNameAlreadyExists)
    in
    Monad.foldM
        ( \context topLevel ->
            case topLevel of
                M.SumType { M.typeName } -> do
                    gatherSumType typeName context

                _ ->
                    return context
        )
        Context.initialContext
        topLevels


dataGatherer :: [M.TopLevel] -> Context -> Gatherer Context
dataGatherer topLevels contextWithTypes =
    Monad.foldM
        ( \context topLevel ->
            case topLevel of
                M.Function { M.functionName, M.typeAnnotation } ->
                    functionGatherer context functionName typeAnnotation

                M.SumType { M.typeName, M.typeVariables, M.dataChoices } -> do
                    constructorGatherer
                        typeName
                        typeVariables
                        dataChoices
                        context
        )
        contextWithTypes
        topLevels


constructorGatherer
    :: TypeId
    -> OrderedSet TypeVariableId
    -> NonEmpty M.DataChoice
    -> Context
    -> Gatherer Context
constructorGatherer typeId typeVariableIds dataChoices context =
    let
        sumType =
            T.Custom (map T.Variable typeVariableIds) typeId

    in
    Monad.foldM
        (\resultingContext (M.DataChoice { tag, args }) -> do
            let type_ = constructorType typeVariableIds args sumType
            freshType <- Gatherer.freshVariable
            Constraint.Constructor
                tag
                typeVariableIds
                type_
                freshType
                |> Gatherer.addConstraint
            Context.addConstructor tag type_ resultingContext
                |> return
        )
        context
        dataChoices


constructorType
    :: OrderedSet TypeVariableId
    -> [TypeAnnotation]
    -> T.Type
    -> T.Type
constructorType typeVariableIds args sumType =
    let
        argsToConstructorType :: [T.Type] -> T.Type
        argsToConstructorType argTypes =
            case argTypes of
                [] ->
                    sumType

                argType : rest ->
                    argsToConstructorType rest
                        |> T.FunctionType argType
                        |> T.Function
    in
    args
        |> map TypeAnnotation.gather
        |> map (\(_, type_) -> type_)
        |> argsToConstructorType



functionGatherer :: Context -> DataId -> TypeAnnotation -> Gatherer Context
functionGatherer context functionName typeAnnotation =
    let
        hasTypeVariable =
            TypeAnnotation.extractTypeVariables
                typeAnnotation
                |> (not << List.isEmpty)

        (_, signatureType) =
            TypeAnnotation.gather typeAnnotation

    in do

    type_ <-
        if hasTypeVariable then do
            returnType <- Gatherer.freshVariable
            Constraint.Definition functionName signatureType returnType
                |> Gatherer.addConstraint

            return (T.Placeholder returnType)
        else
            return signatureType

    Context.addData functionName type_ context
        |> return
